<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="robots" content="noodp" />
        <title>Redis持久化机制 - 我的全新 Hugo 网站</title><meta name="Description" content="This is my cool site"><meta property="og:url" content="https://Parksosaurus.github.io/post/redis-persistence-mechanism-zqmfur.html">
  <meta property="og:site_name" content="我的全新 Hugo 网站">
  <meta property="og:title" content="Redis持久化机制">
  <meta property="og:description" content="Redis持久化机制 ‍ Redis因为是基于内存的数据库，所以需要进行数据的持久化。 Redis通过RDB快照和AOF日志来实现数据的持久化 这两">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-01-16T14:40:51+08:00">
    <meta property="article:modified_time" content="2024-05-01T16:43:31+08:00">

  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Redis持久化机制">
  <meta name="twitter:description" content="Redis持久化机制 ‍ Redis因为是基于内存的数据库，所以需要进行数据的持久化。 Redis通过RDB快照和AOF日志来实现数据的持久化 这两">
<meta name="application-name" content="My cool site">
<meta name="apple-mobile-web-app-title" content="My cool site"><meta name="theme-color" content="#ffffff"><meta name="msapplication-TileColor" content="#da532c"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
        <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link rel="manifest" href="/site.webmanifest"><link rel="canonical" href="https://Parksosaurus.github.io/post/redis-persistence-mechanism-zqmfur.html" /><link rel="next" href="https://Parksosaurus.github.io/post/volatile-detailed-explanation-15k3tj.html" /><link rel="stylesheet" href="/css/style.min.css"><link rel="preload" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
        <noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css"></noscript><link rel="preload" href="https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
        <noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css"></noscript><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "Redis持久化机制",
        "inLanguage": "zh-CN",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https:\/\/Parksosaurus.github.io\/post\/redis-persistence-mechanism-zqmfur.html"
        },"genre": "posts","wordcount":  9153 ,
        "url": "https:\/\/Parksosaurus.github.io\/post\/redis-persistence-mechanism-zqmfur.html","datePublished": "2023-01-16T14:40:51+08:00","dateModified": "2024-05-01T16:43:31+08:00","publisher": {
            "@type": "Organization",
            "name": ""},"author": {
                "@type": "Person",
                "name": "parkso"
            },"description": ""
    }
    </script></head>
    <body data-header-desktop="fixed" data-header-mobile="auto"><script type="text/javascript">(window.localStorage && localStorage.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('auto' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : 'auto' === 'dark')) && document.body.setAttribute('theme', 'dark');</script>

        <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <div class="header-wrapper">
        <div class="header-title">
            <a href="/" title="我的全新 Hugo 网站">My cool site</a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a class="menu-item" href="/posts/"> 文章 </a><a class="menu-item" href="/tags/"> 标签 </a><a class="menu-item" href="/categories/"> 分类 </a><span class="menu-item delimiter"></span><a href="javascript:void(0);" class="menu-item theme-switch" title="Switch Theme">
                    <i class="fas fa-adjust fa-fw" aria-hidden="true"></i>
                </a></div>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/" title="我的全新 Hugo 网站">My cool site</a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><a class="menu-item" href="/posts/" title="">文章</a><a class="menu-item" href="/tags/" title="">标签</a><a class="menu-item" href="/categories/" title="">分类</a><a href="javascript:void(0);" class="menu-item theme-switch" title="Switch Theme">
                <i class="fas fa-adjust fa-fw" aria-hidden="true"></i>
            </a></div>
    </div>
</header><main class="main">
                <div class="container"><div class="toc" id="toc-auto">
            <h2 class="toc-title">Contents</h2>
            <div class="toc-content" id="toc-content-auto"></div>
        </div><article class="page single"><h1 class="single-title animate__animated animate__flipInX">Redis持久化机制</h1><div class="post-meta">
            <div class="post-meta-line"><span class="post-author"><a href="/" title="Author" rel="author" class="author"><i class="fas fa-user-circle fa-fw" aria-hidden="true"></i>parkso</a></span>&nbsp;<span class="post-category">included in <a href="/categories/cs%E6%8A%80%E6%9C%AF/"><i class="far fa-folder fa-fw" aria-hidden="true"></i>CS技术</a></span></div>
            <div class="post-meta-line"><i class="far fa-calendar-alt fa-fw" aria-hidden="true"></i>&nbsp;<time datetime="2023-01-16">2023-01-16</time>&nbsp;<i class="fas fa-pencil-alt fa-fw" aria-hidden="true"></i>&nbsp;9153 words&nbsp;
                <i class="far fa-clock fa-fw" aria-hidden="true"></i>&nbsp;19 minutes&nbsp;</div>
        </div><div class="details toc" id="toc-static"  data-kept="">
                <div class="details-summary toc-title">
                    <span>Contents</span>
                    <span><i class="details-icon fas fa-angle-right" aria-hidden="true"></i></span>
                </div>
                <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li><a href="#rdb文件的创建和载入">RDB文件的创建和载入</a>
      <ul>
        <li><a href="#rdb文件的创建">RDB文件的创建</a></li>
        <li><a href="#rdb文件的载入">RDB文件的载入</a></li>
        <li><a href="#自动间隔性保存">自动间隔性保存</a></li>
      </ul>
    </li>
    <li><a href="#写时复制技术">写时复制技术</a></li>
  </ul>

  <ul>
    <li><a href="#开启aof持久化">开启AOF持久化</a></li>
    <li><a href="#aof持久化过程">AOF持久化过程</a>
      <ul>
        <li><a href="#命令追加">命令追加</a></li>
        <li><a href="#文件写入和同步">文件写入和同步</a></li>
      </ul>
    </li>
    <li><a href="#aof-重写机制">AOF 重写机制</a>
      <ul>
        <li><a href="#出现的问题">出现的问题</a></li>
        <li><a href="#aof重写原理">AOF重写原理</a></li>
        <li><a href="#aof后台重写过程">AOF后台重写过程</a></li>
        <li><a href="#优点">优点</a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#问题">问题</a></li>
    <li><a href="#开启混合持久化">开启混合持久化</a></li>
  </ul>

  <ul>
    <li><a href="#rdb和aof优缺点">RDB和AOF优缺点</a>
      <ul>
        <li><a href="#rdb">RDB</a></li>
        <li><a href="#aof">AOF</a></li>
      </ul>
    </li>
    <li><a href="#如何选择rdb和aof">如何选择RDB和AOF</a></li>
  </ul>
</nav></div>
            </div><div class="content" id="content"><h1 id="redis持久化机制">Redis持久化机制</h1>
<p>‍</p>
<p>Redis因为是基于内存的数据库，所以需要进行数据的持久化。</p>
<p>Redis通过<strong>RDB快照</strong>和<strong>AOF日志</strong>来实现数据的持久化</p>
<p>这两种技术都会各用一个日志文件来记录信息，但是记录的内容是不同的</p>
<ul>
<li>RDB文件的内容是redis保存的键值对转化成的二进制数据</li>
<li>AOF文件的内容是操作命令</li>
</ul>
<h1 id="rdb持久化">RDB持久化</h1>
<h2 id="rdb文件的创建和载入">RDB文件的创建和载入</h2>
<p>‍</p>
<h3 id="rdb文件的创建">RDB文件的创建</h3>
<p>Redis提供了两个命令来生成RDB文件，一个是<code>SAVE</code>​，一个是<code>BGSAVE</code>​ 。</p>
<ul>
<li><code>SAVE</code>​命令会阻塞Redis服务器进程，直到RDB文件创建完毕为止，在服务器进程阻塞期间，服务器不能处理任何命令请求</li>
<li>​<code>BGSAVE</code>命令会派生出一个子进程，然后由子进程负责创建RDB文件，服务器进程(父进程)继续处理请求命令</li>
</ul>
<p>创建RDB文件的实际工作是由<code>rdb.c/rdbSave</code>​函数完成</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">def</span> <span class="nf">SAVE</span><span class="p">()</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="cp">#创建RDB文件
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>    <span class="nf">rdbSave</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="n">def</span> <span class="nf">BGSAVE</span><span class="p">()</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="cp">#创建子进程
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>    <span class="n">pid</span> <span class="o">=</span> <span class="nf">fork</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="n">pid</span> <span class="o">==</span> <span class="mi">0</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">        <span class="cp">#子进程负责创建RDB文件
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>        <span class="nf">rdbSave</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">        <span class="cp">#完成之后向父进程发送信号
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>        <span class="nf">signal_parent</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="n">elif</span> <span class="n">pid</span> <span class="err">＞</span> <span class="mi">0</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">        <span class="cp">#父进程继续处理命令请求，并通过轮询等待子进程的信号
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>        <span class="nf">handle_request_and_wait_signal</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">        <span class="cp">#处理出错情况
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>        <span class="nf">handle_fork_error</span><span class="p">()</span>
</span></span></code></pre></div><p>其中执行fork()创建子进程的时候会有短暂的阻塞</p>
<p>​<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://xducodert-blog.oss-cn-chengdu.aliyuncs.com/test/image-20230116181340-b6hx6au.png"
        data-srcset="https://xducodert-blog.oss-cn-chengdu.aliyuncs.com/test/image-20230116181340-b6hx6au.png, https://xducodert-blog.oss-cn-chengdu.aliyuncs.com/test/image-20230116181340-b6hx6au.png 1.5x, https://xducodert-blog.oss-cn-chengdu.aliyuncs.com/test/image-20230116181340-b6hx6au.png 2x"
        data-sizes="auto"
        alt="https://xducodert-blog.oss-cn-chengdu.aliyuncs.com/test/image-20230116181340-b6hx6au.png"
        title="image" />​</p>
<h4 id="save命令执行时的服务器状态">SAVE命令执行时的服务器状态</h4>
<p>​<code>SAVE</code>​命令执行时，Redis服务器会被阻塞。</p>
<p>只有在服务器执行完<code>SAVE</code>​命令、重新开始接受命令请求之后，客户端发送的所有命令才会被处理。</p>
<h4 id="bgsave命令执行时的服务器状态">BGSAVE命令执行时的服务器状态</h4>
<p>因为BGSAVE命令的保存工作是由子进程执行的，所以在子进程创建RDB文件的过程中，Redis服务器仍然可以继续处理客户端的命令请求，但是，在<code>BGSAVE</code>命令执行期间，服务器处理<code>SAVE</code>、<code>BGSAVE</code>、<code>BGREWRITEAOF</code>三个命令的方式会和平时有所不同。</p>
<ol>
<li>
<p>在<code>BGSAVE</code>命令执行期间，客户端发送的<code>SAVE</code>命令会被服务器拒绝，服务器禁止<code>SAVE</code>​​命令和<code>BGSAVE</code>​​命令同时执行是为了避免父进程和子进程同时执行两个<code>rdbSave</code>​​调用，<em>防</em>止产生竞争条件</p>
</li>
<li>
<p>​<code>BGSAVE</code>命令执行期间，客户端发送的<code>BGSAVE</code>命令会被服务器拒绝，因为同时执行两个<code>BGSAVE</code>​​命令也会产生竞争条件。</p>
</li>
<li>
<p>​<code>BGREWRITEAOF</code>​和<code>BGSAVE</code>​两个命令不能同时执行</p>
<ol>
<li>如果<code>BGSAVE</code>​命令正在执行，那么客户端发送的<code>BGREWRITEAOF</code>​命令会被延迟到<code>BGSAVE</code>​命令执行完毕之后执行</li>
<li>如果<code>BGREWRITEAOF</code>​命令正在执行，那么客户端发送的**<code>BGSAVE</code>**​命令会被服务器拒绝</li>
</ol>
</li>
<li>
<p>因为<code>BGREWRITEAOF</code>​和<code>BGSAVE</code>​两个命令的实际工作都由子进程执行，所以这两个命令在操作方面并没有什么冲突的地方，不能同时执行它们只是一个性能方面的考虑——并发出两个子进程，并且这两个子进程都同时执行大量的磁盘写入操作。</p>
</li>
</ol>
<h3 id="rdb文件的载入">RDB文件的载入</h3>
<p>RDB文件的载入工作是在服务器启动时自动进行的，所以Redis没有专门用于载入RDB文件的命令，只要Redis服务器在启动时检测到RDB文件存在，它就会自动载入RDB文件。</p>
<h4 id="rdb文件载入时的服务器状态">RDB文件载入时的服务器状态</h4>
<p>服务器在载入RDB文件期间，会一直处于阻塞状态，直到载入工作完成为止。</p>
<h3 id="自动间隔性保存">自动间隔性保存</h3>
<p>因为<code>BGSAVE</code>不会阻塞主进程的特点，Redis允许用户通过设置服务器配置的<code>save</code>选项，让服务器每隔一段时间自动执行一次<code>BGSAVE</code>命令。</p>
<p>举例</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">save</span> <span class="mi">900</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl"><span class="n">save</span> <span class="mi">300</span> <span class="mi">10</span>
</span></span><span class="line"><span class="cl"><span class="n">save</span> <span class="mi">60</span> <span class="mi">10000</span>
</span></span></code></pre></div><p>只要满足以下三个条件中的任意一个，BGSAVE命令就会被执行</p>
<ol>
<li>服务器在900秒之内，对数据库进行了至少1次修改。</li>
<li>服务器在300秒之内，对数据库进行了至少10次修改。</li>
<li>服务器在60秒之内，对数据库进行了至少10000次修改。</li>
</ol>
<h4 id="设置保存时间">设置保存时间</h4>
<p>当Redis服务器启动时，用户可以通过指定配置文件或者传入启动参数的方式设置save选项，如果用户没有主动设置save选项，那么服务器会为save选项设置默认条件：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">save</span> <span class="mi">900</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl"><span class="n">save</span> <span class="mi">300</span> <span class="mi">10</span>
</span></span><span class="line"><span class="cl"><span class="n">save</span> <span class="mi">60</span> <span class="mi">10000</span>
</span></span></code></pre></div><h4 id="dirty计数器和lastsave属性">dirty计数器和lastsave属性</h4>
<ol>
<li>dirty计数器记录距离上一次成功执行<code>SAVE</code>​​命令或者<code>BGSAVE</code>​​命令之后，服务器对数据库状态（服务器中的所有数据库）进行了多少次修改（包括写入、删除、更新等操作）</li>
<li>lastsave属性是一个UNIX时间戳，记录了服务器上一次成功执行SAVE命令或者BGSAVE命令的时间</li>
</ol>
<h4 id="检查bgsave自动保存条件是否满足">检查BGSAVE自动保存条件是否满足</h4>
<p>Redis的服务器周期性操作函数serverCron默认每隔100毫秒就会执行一次，该函数用于对正在运行的服务器进行维护，它的其中一项工作就是检查save选项所设置的保存条件是否已经满足，如果满足的话，就执行BGSAVE命令。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">serverCron</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># ...</span>
</span></span><span class="line"><span class="cl">    <span class="c1">#遍历所有保存条件</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">saveparam</span> <span class="ow">in</span> <span class="n">server</span><span class="o">.</span><span class="n">saveparams</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="c1">#计算距离上次执行保存操作有多少秒</span>
</span></span><span class="line"><span class="cl">        <span class="n">save_interval</span> <span class="o">=</span> <span class="n">unixtime_now</span><span class="p">()</span><span class="o">-</span><span class="n">server</span><span class="o">.</span><span class="n">lastsave</span>
</span></span><span class="line"><span class="cl">        <span class="c1">#如果数据库状态的修改次数超过条件所设置的次数</span>
</span></span><span class="line"><span class="cl">        <span class="c1">#并且距离上次保存的时间超过条件所设置的时间</span>
</span></span><span class="line"><span class="cl">        <span class="c1">#那么执行保存操作</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="n">server</span><span class="o">.</span><span class="n">dirty</span> <span class="err">＞</span><span class="o">=</span> <span class="n">saveparam</span><span class="o">.</span><span class="n">changes</span> <span class="ow">and</span> 
</span></span><span class="line"><span class="cl">           <span class="n">save_interval</span> <span class="err">＞</span> <span class="n">saveparam</span><span class="o">.</span><span class="n">seconds</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="n">BGSAVE</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># ...</span>
</span></span></code></pre></div><p>程序会遍历并检查saveparams数组中的所有保存条件，只要有任意一个条件被满足，那么服务器就会执行BGSAVE命令。</p>
<h2 id="写时复制技术">写时复制技术</h2>
<blockquote>
<p>执行 bgsave 过程中，由于是交给子进程来构建 RDB 文件，主线程还是可以继续工作的，此时主线程可以修改数据吗？</p>
<p>执行 bgsave 过程中，Redis 依然<strong>可以继续处理操作命令</strong>的，也就是数据是能被修改的。</p>
<p>那具体如何做到到呢？关键的技术就在于<strong>写时复制技术（Copy-On-Write, COW）。</strong></p>
</blockquote>
<blockquote>
<p>补充：使用linux的时候，父子进程</p>
<p>父进程的数据，子进程可不可以看得到？</p>
<p>常规思想：进程是数据隔离的，</p>
<p>进阶思想：父进程其实可以让子进程看到数据</p>
<p>linux中 export的环境变量，子进程的修改不会破坏父进程，父进程的修改也不会破坏子进程</p>
</blockquote>
<p>执行<code>bgsave</code>​​​​命令时，会通过<code>fork()</code>​​​​创建子进程，<strong>此时子进程和父进程是共享一片内存区域的</strong> 因此创建子进程的时候，会复制父进程的页表，这个<strong>页表记录着虚拟地址和物理地址映射关系</strong>，而不会复制物理内存，也就是说，两者的虚拟空间不同，但其对应的物理空间是同一个 <strong>。</strong></p>
<p>这样一来，子进程就共享了父进程的物理内存数据了，这样能够<strong>节约物理内存资源</strong>​，页表对应的页表项的属性会标记该物理内存的权限为<strong>只读</strong>。</p>
<p>不过，当父进程或者子进程在向这个内存发起写操作时，CPU 就会触发<strong>写保护中断</strong>，这个写保护中断是由于违反权限导致的，然后操作系统会在「写保护中断处理函数」里进行<strong>物理内存的复制</strong>，并重新设置其内存映射关系，将父子进程的内存读写权限设置为<strong>可读写</strong>，最后才会对内存进行写操作</p>
<p>​<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://xducodert-blog.oss-cn-chengdu.aliyuncs.com/test/image-20230116160431-snb0bkk.png"
        data-srcset="https://xducodert-blog.oss-cn-chengdu.aliyuncs.com/test/image-20230116160431-snb0bkk.png, https://xducodert-blog.oss-cn-chengdu.aliyuncs.com/test/image-20230116160431-snb0bkk.png 1.5x, https://xducodert-blog.oss-cn-chengdu.aliyuncs.com/test/image-20230116160431-snb0bkk.png 2x"
        data-sizes="auto"
        alt="https://xducodert-blog.oss-cn-chengdu.aliyuncs.com/test/image-20230116160431-snb0bkk.png"
        title="image" />​</p>
<p><strong>只有在发生修改内存数据的情况时，物理内存才会被复制一份。</strong></p>
<p>这样是为了防止 fork 创建子进程时，由于物理内存数据的复制时间过长而导致父进程长时间阻塞的问题。</p>
<p>​<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://xducodert-blog.oss-cn-chengdu.aliyuncs.com/test/image-20230116160458-hifyfmc.png"
        data-srcset="https://xducodert-blog.oss-cn-chengdu.aliyuncs.com/test/image-20230116160458-hifyfmc.png, https://xducodert-blog.oss-cn-chengdu.aliyuncs.com/test/image-20230116160458-hifyfmc.png 1.5x, https://xducodert-blog.oss-cn-chengdu.aliyuncs.com/test/image-20230116160458-hifyfmc.png 2x"
        data-sizes="auto"
        alt="https://xducodert-blog.oss-cn-chengdu.aliyuncs.com/test/image-20230116160458-hifyfmc.png"
        title="image" />​</p>
<p>当然，操作系统复制父进程页表的时候，父进程也是阻塞中的，不过页表的大小相比实际的物理内存小很多，所以通常复制页表的过程是比较快的。</p>
<p>不过，如果父进程的内存数据非常大，那自然页表也会很大，这时父进程在通过 fork 创建子进程的时候，阻塞的时间也越久。</p>
<p><strong>所以，有两个阶段会导致阻塞父进程：</strong></p>
<ol>
<li>创建子进程的途中，由于要复制父进程的页表等数据结构，阻塞的时间跟页表的大小有关，页表越大，阻塞的时间也越长；</li>
<li>创建完子进程后，如果子进程或者父进程修改了共享数据，就会发生写时复制，这期间会拷贝物理内存，如果内存越大，自然阻塞的时间也越长；</li>
</ol>
<p>也就是说1.拷贝页表结构。2.复制物理内存 会阻塞</p>
<p>复制页表 虚拟地址 &mdash; 只读</p>
<p>修改共享数据 &mdash; 写时复制 &mdash; 拷贝物理内存</p>
<p><strong>减少创建子进程时的性能损耗，从而加快创建子进程的速度，毕竟创建子进程的过程中，是会阻塞主线程的。</strong></p>
<p>但是，如果主线程（父进程）要<strong>修改共享数据里的某一块数据</strong>（比如键值对 <code>A</code>​​​）时，就会发生写时复制，于是这块数据的<strong>物理内存就会被复制一份（键值对 <strong>​</strong><code>A'</code></strong> ​​​ <strong>）</strong> ，然后**主线程在这个数据副本（键值对 ** <strong><code>A'</code></strong>  <strong>）进行修改操作</strong>。与此同时，**bgsave 子进程可以继续把原来的数据（键值对 ** <strong><code>A</code></strong> <strong>）写入到 RDB 文件</strong>。</p>
<p>但是，bgsave 快照过程中，如果主线程修改了共享数据，<strong>发生了写时复制后，RDB 快照保存的是原本的内存数据</strong>，而主线程刚修改的数据，是没办法在这一时间写入 RDB 文件的，只能交由下一次的 bgsave 快照。</p>
<p>所以 Redis 在使用 bgsave 快照过程中，如果主线程修改了内存数据，不管是否是共享的内存数据，RDB 快照都无法写入主线程刚修改的数据，因为此时主线程（父进程）的内存数据和子进程的内存数据已经分离了，子进程写入到 RDB 文件的内存数据只能是原本的内存数据。</p>
<p>如果系统恰好在 RDB 快照文件创建完毕后崩溃了，那么 Redis 将会丢失主线程在快照期间修改的数据。</p>
<p><strong>无法保证实时数据落盘</strong></p>
<h1 id="aof持久化">AOF持久化</h1>
<p>AOF持久化是通过保存Redis服务器所执行的<strong>写命令</strong>来记录数据库状态的。</p>
<p>​<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://xducodert-blog.oss-cn-chengdu.aliyuncs.com/test/image-20230116161120-j12y876.png"
        data-srcset="https://xducodert-blog.oss-cn-chengdu.aliyuncs.com/test/image-20230116161120-j12y876.png, https://xducodert-blog.oss-cn-chengdu.aliyuncs.com/test/image-20230116161120-j12y876.png 1.5x, https://xducodert-blog.oss-cn-chengdu.aliyuncs.com/test/image-20230116161120-j12y876.png 2x"
        data-sizes="auto"
        alt="https://xducodert-blog.oss-cn-chengdu.aliyuncs.com/test/image-20230116161120-j12y876.png"
        title="image" />​</p>
<h2 id="开启aof持久化">开启AOF持久化</h2>
<p>在 Redis 中 AOF 持久化 功能默认是不开启的，需要我们修改 <code>redis.conf</code>​ 配置文件中的以下参数：</p>
<p>​<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://xducodert-blog.oss-cn-chengdu.aliyuncs.com/test/image-20230116161225-z4t8o3q.png"
        data-srcset="https://xducodert-blog.oss-cn-chengdu.aliyuncs.com/test/image-20230116161225-z4t8o3q.png, https://xducodert-blog.oss-cn-chengdu.aliyuncs.com/test/image-20230116161225-z4t8o3q.png 1.5x, https://xducodert-blog.oss-cn-chengdu.aliyuncs.com/test/image-20230116161225-z4t8o3q.png 2x"
        data-sizes="auto"
        alt="https://xducodert-blog.oss-cn-chengdu.aliyuncs.com/test/image-20230116161225-z4t8o3q.png"
        title="image" />​</p>
<h2 id="aof持久化过程">AOF持久化过程</h2>
<p>AOF持久化功能的实现可以分为<strong>命令追加</strong>、<strong>文件写入</strong>、<strong>文件同步</strong>三个步骤</p>
<blockquote>
<p>Redis是“写后”日志，Redis先执行命令，把数据写入内存，然后才记录日志。日志里记录的是Redis收到的每一条命令，这些命令是以文本形式保存。PS: 大多数的数据库采用的是写前日志（WAL），例如MySQL，通过写前日志和两阶段提交，实现数据和逻辑的一致性。</p>
</blockquote>
<p>​<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://xducodert-blog.oss-cn-chengdu.aliyuncs.com/test/image-20230413144927-rdjembx.png"
        data-srcset="https://xducodert-blog.oss-cn-chengdu.aliyuncs.com/test/image-20230413144927-rdjembx.png, https://xducodert-blog.oss-cn-chengdu.aliyuncs.com/test/image-20230413144927-rdjembx.png 1.5x, https://xducodert-blog.oss-cn-chengdu.aliyuncs.com/test/image-20230413144927-rdjembx.png 2x"
        data-sizes="auto"
        alt="https://xducodert-blog.oss-cn-chengdu.aliyuncs.com/test/image-20230413144927-rdjembx.png"
        title="image" />​</p>
<h3 id="命令追加">命令追加</h3>
<p>当AOF持久化功能处于打开状态时，服务器在执行完一个写命令之后，会以协议格式将被执行的写命令追加到服务器状态的<strong>aof_buf缓冲区</strong>的末尾：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">redisServer</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// AOF缓冲区
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">sds</span> <span class="n">aof_buf</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span></code></pre></div><p><strong>举例：</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">redis</span><span class="err">＞</span> <span class="n">SET</span> <span class="n">KEY</span> <span class="n">VALUE</span>
</span></span><span class="line"><span class="cl"><span class="n">OK</span>
</span></span></code></pre></div><p>那么服务器在<strong>执行这个SET命令之后</strong>，会将以下协议<a href="" rel="">内容</a>追加到aof_buf缓冲区的末尾</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="o">*</span><span class="mi">3</span><span class="err">\</span><span class="n">r</span><span class="err">\</span><span class="n">n</span><span class="err">$</span><span class="mi">3</span><span class="err">\</span><span class="n">r</span><span class="err">\</span><span class="n">nSET</span><span class="err">\</span><span class="n">r</span><span class="err">\</span><span class="n">n</span><span class="err">$</span><span class="mi">3</span><span class="err">\</span><span class="n">r</span><span class="err">\</span><span class="n">nKEY</span><span class="err">\</span><span class="n">r</span><span class="err">\</span><span class="n">n</span><span class="err">$</span><span class="mi">5</span><span class="err">\</span><span class="n">r</span><span class="err">\</span><span class="n">nVALUE</span><span class="err">\</span><span class="n">r</span><span class="err">\</span><span class="n">n</span>
</span></span></code></pre></div><ul>
<li>「<code>*3</code>​​」表示当前命令有三个部分，每部分都是以「<code>$+数字</code>​​」开头，后面紧跟着具体的命令、键或值。</li>
<li>「<code>数字</code>​​」表示这部分中的命令、键或值一共有多少字节。例如，「<code>$3 set</code>​​」表示这部分有 3 个字节，也就是「<code>set</code>​​」命令这个字符串的长度。</li>
</ul>
<p>写后日志</p>
<p><strong>Redis</strong>​<strong>先执行写操作再追加命令****的好处：</strong></p>
<ol>
<li>
<p><strong>避免额外的检查开销</strong></p>
<p>因为如果先将写操作命令记录到 AOF 日志里，再执行该命令的话，如果当前的命令语法有问题，那么如果不进行命令语法检查，该错误的命令记录到 AOF 日志里后，Redis 在使用日志恢复数据时，就可能会出错。</p>
<p>而如果先执行写操作命令再记录日志的话，只有在该命令执行成功后，才将命令记录到 AOF 日志里，这样就不用额外的检查开销，保证记录在 AOF 日志里的命令都是可执行并且正确的。</p>
</li>
<li>
<p><strong>不会阻塞****当前写操作命令的执行</strong></p>
<p>因为当写操作命令执行成功后，才会将命令记录到 AOF 日志。</p>
</li>
</ol>
<p>缺点：</p>
<ol>
<li>
<p>如果命令执行完成，写日志之前宕机了，会丢失数据</p>
<p>丢失的不多</p>
</li>
</ol>
<h3 id="文件写入和同步">文件写入和同步</h3>
<h4 id="概念">概念</h4>
<p>在现在操作系统中，当用户调用write函数，将一些数据写入到文件的时候，操作系统通常会将写入的数据暂时保存在一个内存缓冲区里面，等到缓冲区的空间被填、或者超过了指定的时限之后，才真正地将缓冲区中的数据写入到磁盘里面。</p>
<p><strong>优点：</strong></p>
<p>提高了效率</p>
<p><strong>缺点：</strong></p>
<p>写入数据具有安全问题，因为如果计算机发生停机，那么保存在内存缓冲区中里面的写入数据将会消失</p>
<p><strong>解决方案：</strong></p>
<p>系统提供了<code>fsync</code>和<code>fdatasync</code>两个同步函数，它们可以强制让操作系统立即将缓冲区中的数据写入到硬盘里面，从而确保写入数据的安全性。</p>
<h4 id="过程">过程</h4>
<p>在 Redis 中客户端向服务器发送相关写命令请求，这时服务器中有个用于处理这些命令的事件循环进程，对这些命令进行处理，并将相关信息处理的结果反馈给客户端，如：&quot;<code>OK</code>​​&quot;，等。</p>
<p>同时，在这个期间，服务器中命令请求器会将相关写命令追加到 <code>aof_buf </code>​缓冲区和<code>aof_rewrite_buf</code>​重写缓冲区。</p>
<p>这个阶段服务器进程会处理这三个操作</p>
<p>​<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://xducodert-blog.oss-cn-chengdu.aliyuncs.com/test/image-20230116163259-b1mi258.png"
        data-srcset="https://xducodert-blog.oss-cn-chengdu.aliyuncs.com/test/image-20230116163259-b1mi258.png, https://xducodert-blog.oss-cn-chengdu.aliyuncs.com/test/image-20230116163259-b1mi258.png 1.5x, https://xducodert-blog.oss-cn-chengdu.aliyuncs.com/test/image-20230116163259-b1mi258.png 2x"
        data-sizes="auto"
        alt="https://xducodert-blog.oss-cn-chengdu.aliyuncs.com/test/image-20230116163259-b1mi258.png"
        title="image" />​</p>
<ol>
<li>执行客户端的命令</li>
<li>将执行后的写命令append入aof_buf中</li>
<li>将执行后的写命令append到aof_rewrite_buf中</li>
</ol>
<p>​<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://xducodert-blog.oss-cn-chengdu.aliyuncs.com/test/image-20230116163259-b1mi258.png"
        data-srcset="https://xducodert-blog.oss-cn-chengdu.aliyuncs.com/test/image-20230116163259-b1mi258.png, https://xducodert-blog.oss-cn-chengdu.aliyuncs.com/test/image-20230116163259-b1mi258.png 1.5x, https://xducodert-blog.oss-cn-chengdu.aliyuncs.com/test/image-20230116163259-b1mi258.png 2x"
        data-sizes="auto"
        alt="https://xducodert-blog.oss-cn-chengdu.aliyuncs.com/test/image-20230116163259-b1mi258.png"
        title="image" />​</p>
<p>当进行 AOF持久化的时候，对于 aof_buf 中的数据需要写入并同步到 appendonly.aof 文件中</p>
<p>​<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://xducodert-blog.oss-cn-chengdu.aliyuncs.com/test/image-20230116164105-sa8u44c.png"
        data-srcset="https://xducodert-blog.oss-cn-chengdu.aliyuncs.com/test/image-20230116164105-sa8u44c.png, https://xducodert-blog.oss-cn-chengdu.aliyuncs.com/test/image-20230116164105-sa8u44c.png 1.5x, https://xducodert-blog.oss-cn-chengdu.aliyuncs.com/test/image-20230116164105-sa8u44c.png 2x"
        data-sizes="auto"
        alt="https://xducodert-blog.oss-cn-chengdu.aliyuncs.com/test/image-20230116164105-sa8u44c.png"
        title="image" />​</p>
<h5 id="三种写回策略">三种写回策略</h5>
<p>是否将 aof_buf 缓冲区中内容写入AOF文件中，由 redis.conf 配置文件中的 appendfsync 设置的值来决定，通过 flushAppendFile 函数来进行相关操作。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">//事件轮询函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">def</span> <span class="nf">evenloop</span><span class="p">()</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">　　<span class="k">while</span> <span class="nl">True</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">       <span class="p">........</span>
</span></span><span class="line"><span class="cl">　　　　<span class="c1">//是否将 aof_buf 缓冲区中的内容写入并同步到 appendonly.aof 文件中。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>       <span class="nf">flushAppendOnlyFile</span><span class="p">()</span>
</span></span></code></pre></div><table>
<thead>
<tr>
<th>appendfsync 选项的值</th>
<th>flushAppendOnlyFile 函数的行为</th>
</tr>
</thead>
<tbody>
<tr>
<td>always</td>
<td>将 aof_buf 缓冲区中的所有内容写入并同步到 AOF 文件中（最安全，但性能差）</td>
</tr>
<tr>
<td>everysec</td>
<td>将 aof_buf 缓冲区中的所有内容写入并同步到 AOF 文件中，如果上次同步 AOF 文件的时间距离现在超过 1 秒钟，那么会再次对 AOF 文件进行同步。 （安全，性能较好）</td>
</tr>
<tr>
<td>no</td>
<td>将 aof_buf 缓冲区中的所有内容写入并同步到 AOF 文件中，但不对 AOF 文件进行同步，何时进行同步一般有操作系统来决定。（一般为 30 秒，不安全，性能最好）</td>
</tr>
</tbody>
</table>
<p>​<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://xducodert-blog.oss-cn-chengdu.aliyuncs.com/test/image-20230116164404-zs0e8xz.png"
        data-srcset="https://xducodert-blog.oss-cn-chengdu.aliyuncs.com/test/image-20230116164404-zs0e8xz.png, https://xducodert-blog.oss-cn-chengdu.aliyuncs.com/test/image-20230116164404-zs0e8xz.png 1.5x, https://xducodert-blog.oss-cn-chengdu.aliyuncs.com/test/image-20230116164404-zs0e8xz.png 2x"
        data-sizes="auto"
        alt="https://xducodert-blog.oss-cn-chengdu.aliyuncs.com/test/image-20230116164404-zs0e8xz.png"
        title="image" />​</p>
<p>在<strong>概念</strong>中我们谈到</p>
<blockquote>
<p>系统提供了<code>fsync</code>​和<code>fdatasync</code>​两个同步函数，它们可以强制让操作系统立即将缓冲区中的数据写入到硬盘里面，从而确保写入数据的安全性。</p>
</blockquote>
<p>其实以上三种策略只是在控制 <code>fsync()</code>​​ 函数的调用时机</p>
<p>当应用程序向文件写入数据时，内核通常先将数据复制到内核缓冲区中(写入)，然后排入队列，然后由内核决定何时写入硬盘(同步)。</p>
<p>​<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://xducodert-blog.oss-cn-chengdu.aliyuncs.com/test/image-20230116164627-z913ra4.png"
        data-srcset="https://xducodert-blog.oss-cn-chengdu.aliyuncs.com/test/image-20230116164627-z913ra4.png, https://xducodert-blog.oss-cn-chengdu.aliyuncs.com/test/image-20230116164627-z913ra4.png 1.5x, https://xducodert-blog.oss-cn-chengdu.aliyuncs.com/test/image-20230116164627-z913ra4.png 2x"
        data-sizes="auto"
        alt="https://xducodert-blog.oss-cn-chengdu.aliyuncs.com/test/image-20230116164627-z913ra4.png"
        title="image" />​</p>
<p>如果想要应用程序向文件写入数据后，能立马将数据同步到硬盘，就可以调用 <code>fsync()</code>​​ 函数，这样内核就会将内核缓冲区的数据直接写入到硬盘，<a href="" rel="">等到</a>硬盘写操作完成后，该函数才会返回。</p>
<ul>
<li>Always 策略就是每次写入 AOF 文件数据后，就执行 fsync() 函数；</li>
<li>Everysec 策略就会创建一个异步任务来执行 fsync() 函数；</li>
<li>No 策略就是永不执行 fsync() 函数;</li>
</ul>
<h2 id="aof-重写机制">AOF 重写机制</h2>
<h3 id="出现的问题">出现的问题</h3>
<p>AOF 日志是一个文件，随着执行的写操作命令越来越多，文件的大小会越来越大。</p>
<p>如果当 AOF 日志文件过大就会带来性能问题，比如重启 Redis 后，需要读 AOF 文件的内容以恢复数据，如果文件过大，整个恢复的过程就会很慢。</p>
<h3 id="aof重写原理">AOF重写原理</h3>
<p>Redis 为了避免 AOF 文件越写越大，提供了 <strong>AOF 重写机制</strong>，当 AOF 文件的大小超过所设定的阈值后，Redis 就会启用 AOF 重写机制，来压缩 AOF 文件。</p>
<p>AOF 重写机制是在重写时，读取当前数据库中的所有键值对，然后将每一个键值对用一条命令记录到「新的 AOF 文件」，等到全部记录后，就将新的 AOF 文件替换掉现有的 AOF 文件。</p>
<p>相当于是用操作来对当前数据库中的数据进行快照</p>
<p>举例：</p>
<p>举个例子，在没有使用重写机制前，假设前后执行了「<em>set name xiaolin</em>」和「<em>set name xiaolincoding</em>」这两个命令的话，就会将这两个命令记录到 AOF 文件。</p>
<p>​<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://xducodert-blog.oss-cn-chengdu.aliyuncs.com/test/image-20230116165141-csa8gdn.png"
        data-srcset="https://xducodert-blog.oss-cn-chengdu.aliyuncs.com/test/image-20230116165141-csa8gdn.png, https://xducodert-blog.oss-cn-chengdu.aliyuncs.com/test/image-20230116165141-csa8gdn.png 1.5x, https://xducodert-blog.oss-cn-chengdu.aliyuncs.com/test/image-20230116165141-csa8gdn.png 2x"
        data-sizes="auto"
        alt="https://xducodert-blog.oss-cn-chengdu.aliyuncs.com/test/image-20230116165141-csa8gdn.png"
        title="image" />​</p>
<p>但是<strong>在使用重写机制后，就会读取 name 最新的 value（键值对） ，然后用一条 「set name xiaolincoding」命令记录到新的 AOF 文件</strong>，之前的第一个命令就没有必要记录了，因为它属于「历史」命令，没有作用了。这样一来，一个键值对在重写日志中只用一条命令就行了。</p>
<h3 id="aof后台重写过程">AOF后台重写过程</h3>
<p>写入 AOF 日志的操作是在主进程中的，但是在触发 AOF 重写时，<strong>比如当 AOF 文件大于 64M 时，就会对 AOF 文件进行重写</strong>，这时需要读取所有缓存的键值对数据，并为每个键值对生成一条命令，然后将其写入到新的 AOF 文件，重写完后，就把现在的 AOF 文件替换掉。</p>
<p>这个过程其实是很耗时的，所以重写的操作不能放在主进程里。</p>
<p>所以，Redis 的​<strong>重写 AOF 过程是由后台子进程 ** <em><strong>bgrewriteaof</strong></em> ** 来完成的</strong>​，这么做可以达到两个好处：</p>
<ol>
<li>
<p>子进程进行 AOF 重写期间，主进程可以继续处理命令请求，从而避免阻塞主进程</p>
</li>
<li>
<p>子进程带有主进程的数据副本，这里使用子进程而不是线程，因为如果是使用线程，多线程之间会共享内存，那么在修改共享内存数据的时候，需要通过加锁来保证数据的安全，而这样就会降低性能。实现了无锁</p>
<p>而使用子进程，创建子进程时，父子进程是共享内存数据的，不过这个共享的内存只能以只读的方式，而当父子进程任意一方修改了该共享内存，就会发生「写时复制」，于是父子进程就有了独立的数据副本，就不用加锁来保证数据安全。</p>
</li>
</ol>
<p>主进程在通过 <code>fork</code>​ 系统调用生成 bgrewriteaof 子进程时，操作系统会把主进程的「<strong>页表</strong>」复制一份给子进程，这个页表记录着虚拟地址和物理地址映射关系，而不会复制物理内存，也就是说，两者的虚拟空间不同，但其对应的物理空间是同一个。</p>
<p>​<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://xducodert-blog.oss-cn-chengdu.aliyuncs.com/test/image-20230116160431-snb0bkk.png"
        data-srcset="https://xducodert-blog.oss-cn-chengdu.aliyuncs.com/test/image-20230116160431-snb0bkk.png, https://xducodert-blog.oss-cn-chengdu.aliyuncs.com/test/image-20230116160431-snb0bkk.png 1.5x, https://xducodert-blog.oss-cn-chengdu.aliyuncs.com/test/image-20230116160431-snb0bkk.png 2x"
        data-sizes="auto"
        alt="https://xducodert-blog.oss-cn-chengdu.aliyuncs.com/test/image-20230116160431-snb0bkk.png"
        title="image" />​</p>
<p>这样一来，子进程就共享了父进程的物理内存数据了，这样能够<strong>节约物理内存资源</strong>，页表对应的页表项的属性会标记该物理内存的权限为<strong>只读</strong>。</p>
<p>不过，当父进程或者子进程在向这个内存发起写操作时，CPU 就会触发​<strong>写保护中断</strong>​，这个写保护中断是由于违反权限导致的，然后操作系统会在「写保护中断处理函数」里进行​<strong>物理内存的复制</strong>​，并重新设置其内存映射关系，将父子进程的内存读写权限设置为​<strong>可读写</strong>​，最后才会对内存进行写操作，这个过程被称为「​<em><em>写时复制(<strong>​</strong></em>Copy On Write</em>**​ <strong>)</strong> ​」。</p>
<p>触发<strong>重写机制</strong>后，主进程就会<strong>创建重写 AOF 的子进程</strong>，此时父子进程共享物理内存，重写子进程只会对这个内存进行只读，重写 AOF 子进程会读取数据库里的所有数据，并逐一把内存数据的键值对转换成一条命令，再将命令记录到重写日志（新的 AOF 文件）。</p>
<p>但是子进程重写过程中，主进程依然可以正常处理命令。</p>
<p>如果此时​<strong>主进程修改了已经存在 key-value，就会发生写时复制，注意这里只会复制主进程修改的物理内存数据，没修改物理内存还是与子进程共享的</strong>​。</p>
<p>所以如果这个阶段修改的是一个 bigkey，也就是数据量比较大的 key-value 的时候，这时复制的物理内存数据的过程就会比较耗时，有阻塞主进程的风险。</p>
<p>还有个问题，重写 AOF 日志过程中，如果主进程修改了已经存在 key-value，此时这个 key-value 数据在子进程的内存数据就跟主进程的内存数据不一致了，这时要怎么办呢?</p>
<p>为了解决这种数据不一致问题，Redis 设置了一个 <strong>AOF 重写缓冲区</strong>，这个缓冲区在创建 bgrewriteaof 子进程之后开始使用。</p>
<p>在重写 AOF 期间，当 Redis 执行完一个写命令之后，它会<strong>同时将这个写命令写入到 「AOF 缓冲区」和 「AOF 重写缓冲区」</strong> 。</p>
<p>​<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://xducodert-blog.oss-cn-chengdu.aliyuncs.com/test/image-20230116171122-l2lv5mz.png"
        data-srcset="https://xducodert-blog.oss-cn-chengdu.aliyuncs.com/test/image-20230116171122-l2lv5mz.png, https://xducodert-blog.oss-cn-chengdu.aliyuncs.com/test/image-20230116171122-l2lv5mz.png 1.5x, https://xducodert-blog.oss-cn-chengdu.aliyuncs.com/test/image-20230116171122-l2lv5mz.png 2x"
        data-sizes="auto"
        alt="https://xducodert-blog.oss-cn-chengdu.aliyuncs.com/test/image-20230116171122-l2lv5mz.png"
        title="image" />​</p>
<p>也就是说，在 bgrewriteaof 子进程执行 AOF 重写期间，主进程需要执行以下三个工作:</p>
<ul>
<li>执行客户端发来的命令；</li>
<li>将执行后的写命令追加到 「AOF 缓冲区」；</li>
<li>将执行后的写命令追加到 「AOF 重写缓冲区」；</li>
</ul>
<p>当子进程完成 AOF 重写工作（<em>扫描数据库中所有数据，逐一把内存数据的键值对转换成一条命令，再将命令记录到重写日志</em>）后，会向主进程发送一条信号，信号是进程间通讯的一种方式，且是异步的。</p>
<p>主进程收到该信号后，会调用一个信号处理函数，该函数主要做以下工作：</p>
<ul>
<li>
<p>将 AOF 重写缓冲区中的所有内容<strong>追加</strong>到新的 AOF 的文件中，使得新旧两个 AOF 文件所保存的数据库状态一致；</p>
<p>‍</p>
</li>
<li>
<p>新的 AOF 的文件进行改名，覆盖现有的 AOF 文件。</p>
</li>
</ul>
<p>也就是说子进程进行重写后 父进程会对该aof文件进行矫正 把自己这段时间对数据的修改命令追加到aof文件末尾</p>
<p><strong>与RDB中BGSAVE写时复制技术的区别：</strong></p>
<ol>
<li>BGSAVE快照过程中，如果主线程修改了共享数据，<strong>发生了写时复制后，RDB 快照保存的是原本的内存数据</strong>，而主线程刚修改的数据，是没办法在这一时间写入<a href="" rel=""> </a>RDB 文件的，只能交由下一次的 bgsave 快照。</li>
<li>AOF重写虽然会进行写时复制将主进程和子进程区分开，但是主进程会将<strong>写命令写入到 「AOF 缓冲区」和 「AOF 重写缓冲区」</strong> 。当子进程完成 AOF 重写工作后，主进程会将 AOF 重写缓冲区中的所有内容追加到新的 AOF 的文件中，使得新旧两个 AOF 文件所保存的数据库状态一致</li>
</ol>
<h3 id="优点">优点</h3>
<p>重写机制的妙处在于，尽管某个键值对被多条写命令反复修改，<strong>最终也只需要根据这个「键值对」当前的最新状态，然后用一条命令去记录键值对</strong>，代替之前记录这个键值对的多条命令，这样就减少了 AOF 文件中的命令数量。最后在重写工作完成后，将新的 AOF 文件覆盖现有的 AOF 文件</p>
<blockquote>
<p>为什么重写 AOF 的时候，不直接复用现有的 AOF 文件，而是先写到新的 AOF 文件再覆盖过去？</p>
</blockquote>
<p>因为​<strong>如果 AOF 重写过程中失败了，现有的 AOF 文件就会造成</strong>****​，可能无法用于恢复使用。</p>
<p>所以 AOF 重写过程，先重写到新的 AOF 文件，重写失败的话，就直接删除这个文件就好，不会对现有的 AOF 文件造成影响。</p>
<h1 id="混合持久化">混合持久化</h1>
<h2 id="问题">问题</h2>
<p>尽管 RDB 比 AOF 的数据恢复速度快，但是快照的频率不好把握：</p>
<ul>
<li>如果频率太低，两次快照间一旦服务器发生宕机，就可能会比较多的数据丢失；</li>
<li>如果频率太高，频繁写入磁盘和创建子进程会带来额外的性能开销。</li>
</ul>
<h2 id="开启混合持久化">开启混合持久化</h2>
<p>如果想要开启混合持久化功能，可以在 Redis 配置文件将下面这个配置项设置成 yes</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">aof</span><span class="o">-</span><span class="n">use</span><span class="o">-</span><span class="n">rdb</span><span class="o">-</span><span class="n">preamble</span> <span class="n">yes</span>
</span></span></code></pre></div><p>混合持久化其实是对AOF持久化机制的一种优化，工作在 <strong>AOF 日志重写过程</strong>中。</p>
<p>当开启了混合持久化时，在 AOF 重写日志时，<code>fork</code> 出来的重写子进程会先将与主线程共享的内存数据以 RDB 方式写入到 AOF 文件，然后主线程处理的操作命令会被记录在重写缓冲区里，重写缓冲区里的增量命令会以 AOF 方式写入到 AOF 文件，写入完成后通知主进程将新的含有 RDB 格式和 AOF 格式的 AOF 文件替换旧的的 AOF 文件。</p>
<p>也就是说，使用了混合持久化，AOF 文件的<strong>前半部分是 RDB 格式的全量数据，后半部分是 AOF 格式的增量数据</strong>。</p>
<p>​<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://xducodert-blog.oss-cn-chengdu.aliyuncs.com/test/image-20230116172246-b5kv9im.png"
        data-srcset="https://xducodert-blog.oss-cn-chengdu.aliyuncs.com/test/image-20230116172246-b5kv9im.png, https://xducodert-blog.oss-cn-chengdu.aliyuncs.com/test/image-20230116172246-b5kv9im.png 1.5x, https://xducodert-blog.oss-cn-chengdu.aliyuncs.com/test/image-20230116172246-b5kv9im.png 2x"
        data-sizes="auto"
        alt="https://xducodert-blog.oss-cn-chengdu.aliyuncs.com/test/image-20230116172246-b5kv9im.png"
        title="image" />​</p>
<p>优点：</p>
<ol>
<li>
<p>重启 Redis 加载数据的时候，由于前半部分是 RDB 内容，这样<strong>加载的时候速度会很快</strong>。（aof加载数据没有rdb快）</p>
</li>
<li>
<p>加载完 RDB 的内容后，才会加载后半部分的 AOF 内容，这里的内容是 Redis 后台子进程重写 AOF 期间，主线程处理的操作命令，可以使得<strong>数据更少的丢失</strong>。</p>
</li>
</ol>
<h1 id="对比两种持久化机制">对比两种持久化机制</h1>
<h2 id="rdb和aof优缺点">RDB和AOF优缺点</h2>
<h3 id="rdb">RDB</h3>
<ol>
<li>
<p>优点</p>
<ul>
<li>RDB快照是一个压缩过的非常紧凑的文件，保存着某个时间点的数据集，<strong>适合做数据的备份</strong></li>
<li>可以最大化Redis的性能，在保存RDB文件时，服务器进程只需fork一个子进程来完成RDB文件的创建，父进程不需要做IO操作</li>
<li>与AOF相比，恢复大数据集的时候会更快</li>
</ul>
</li>
<li>
<p>缺点</p>
<ul>
<li>RDB的数据安全性不如AOF，保存整个数据集的过程是比较繁重的，据配置可能要几分钟才快照一次，如果服务器宕机，那么就可能丢失几分钟的数据</li>
<li>Redis数据集较大时，fork的子进程要完成快照会比较耗CPU、耗时</li>
</ul>
</li>
</ol>
<h3 id="aof">AOF</h3>
<ol>
<li>
<p>优点：</p>
<ul>
<li>数据更完整，安全性更高，秒级数据丢失（取决fsync策略，如果是everysec，最多丢失1秒的数据）</li>
<li>AOF文件是一个只进行追加的日志，且写入操作是以Redis协议的格式保存的，内容是可读的，适合误删紧急回复。</li>
</ul>
</li>
<li>
<p>缺点：</p>
<ul>
<li>对于相同的数据集，AOF文件的体积要大于RDB文件，数据恢复也会比较慢</li>
<li>根据所使用的 fsync 策略，AOF 的速度可能会慢于 RDB。 不过在一般情况下， 每秒 fsync 的性能依然非常高</li>
</ul>
</li>
</ol>
<h2 id="如何选择rdb和aof">如何选择RDB和AOF</h2>
<ul>
<li>如果是数据不那么敏感，且可以从其他地方重新生成补回的，那么可以关闭持久化</li>
<li>如果是数据比较重要，不想再从其他地方获取，且可以承受数分钟的数据丢失，比如缓存等，那么可以只使用RDB</li>
<li>如果是用做内存数据库，要使用Redis的持久化，建议是RDB和AOF都开启，或者定期执行<code>bgsave</code>​做快照备份，RDB方式更适合做数据的备份，AOF可以保证数据不丢失。</li>
</ul>
<p>‍</p>
<h1 id="最终大总结">最终大总结</h1>
<p>RDB和AOF都提供了开启子进程 这里用子进程的原因是？</p>
<p>避免多线程上下文开销 并且不需要保证锁</p>
<p>‍</p>
<p>RDB bgsave和 AOF bgrewriteaof 执行过程中的异同</p>
<ol>
<li>
<p>相同点</p>
<p>因为都需要开启一个子进程 所以在发生写冲突时候会触发写保护中断 通过“写时复制技术”来保证</p>
</li>
<li>
<p>不同点</p>
<p>rdb的bgsave是一个后台落盘的子进程</p>
<p>aof的bgrewriteaof只是一个进行重写aof的子进程</p>
</li>
</ol>
<p>‍</p>
</div><div class="post-footer" id="post-footer">
    <div class="post-info">
        <div class="post-info-line">
            <div class="post-info-mod">
                <span>Updated on 2024-05-01</span>
            </div></div>
        <div class="post-info-line">
            <div class="post-info-md"></div>
            <div class="post-info-share">
                <span><a href="javascript:void(0);" title="Share on Twitter" data-sharer="twitter" data-url="https://Parksosaurus.github.io/post/redis-persistence-mechanism-zqmfur.html" data-title="Redis持久化机制"><i class="fab fa-twitter fa-fw" aria-hidden="true"></i></a><a href="javascript:void(0);" title="Share on Facebook" data-sharer="facebook" data-url="https://Parksosaurus.github.io/post/redis-persistence-mechanism-zqmfur.html"><i class="fab fa-facebook-square fa-fw" aria-hidden="true"></i></a><a href="javascript:void(0);" title="Share on Hacker News" data-sharer="hackernews" data-url="https://Parksosaurus.github.io/post/redis-persistence-mechanism-zqmfur.html" data-title="Redis持久化机制"><i class="fab fa-hacker-news fa-fw" aria-hidden="true"></i></a><a href="javascript:void(0);" title="Share on Line" data-sharer="line" data-url="https://Parksosaurus.github.io/post/redis-persistence-mechanism-zqmfur.html" data-title="Redis持久化机制"><i data-svg-src="https://cdn.jsdelivr.net/npm/simple-icons@7.3.0/icons/line.svg" aria-hidden="true"></i></a><a href="javascript:void(0);" title="Share on 微博" data-sharer="weibo" data-url="https://Parksosaurus.github.io/post/redis-persistence-mechanism-zqmfur.html" data-title="Redis持久化机制"><i class="fab fa-weibo fa-fw" aria-hidden="true"></i></a></span>
            </div>
        </div>
    </div>

    <div class="post-info-more">
        <section class="post-tags"></section>
        <section>
            <span><a href="javascript:void(0);" onclick="window.history.back();">Back</a></span>&nbsp;|&nbsp;<span><a href="/">Home</a></span>
        </section>
    </div>

    <div class="post-nav">
            <a href="/post/volatile-detailed-explanation-15k3tj.html" class="next" rel="next" title="volatile详解">volatile详解<i class="fas fa-angle-right fa-fw" aria-hidden="true"></i></a></div>
</div>
</article></div>
            </main><footer class="footer">
        <div class="footer-container"><div class="footer-line">Powered by <a href="https://gohugo.io/" target="_blank" rel="noopener noreffer" title="Hugo 0.126.2">Hugo</a> | Theme - <a href="https://github.com/dillonzq/LoveIt" target="_blank" rel="noopener noreffer" title="LoveIt 0.2.11"><i class="far fa-kiss-wink-heart fa-fw" aria-hidden="true"></i> LoveIt</a>
                </div><div class="footer-line" itemscope itemtype="http://schema.org/CreativeWork"><i class="far fa-copyright fa-fw" aria-hidden="true"></i><span itemprop="copyrightYear">2022 - 2024</span><span class="author" itemprop="copyrightHolder">&nbsp;<a href="/" target="_blank">xxxx</a></span></div>
        </div>
    </footer></div>

        <div id="fixed-buttons"><a href="#" id="back-to-top" class="fixed-button" title="Back to Top">
                <i class="fas fa-arrow-up fa-fw" aria-hidden="true"></i>
            </a><a href="#" id="view-comments" class="fixed-button" title="View Comments">
                <i class="fas fa-comment fa-fw" aria-hidden="true"></i>
            </a>
        </div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/clipboard@2.0.11/dist/clipboard.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/sharer.js@0.5.1/sharer.min.js"></script><script type="text/javascript">window.config={"code":{"copyTitle":"Copy to clipboard","maxShownLines":50},"comment":{}};</script><script type="text/javascript" src="/js/theme.min.js"></script></body>
</html>
